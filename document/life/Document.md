
> step1.找一张美美的封面

![face style](https://i.imgur.com/KpGRIfY.jpg)

> step2.简要概况

![列表图](https://i.imgur.com/J8Y5sDE.png)

## 依赖注入(DI)与控制反转(IOC) ##

> 什么是DI?什么是IOC?

### IOC-控制反转: ###

	在常见的项目中，经常会出现类a需要使用类b的方法的情况,即类a需要类b的对象引用
	这时我们通常会采用三种方案来添加类b的对象引用:setXxx,构造方法,直接在类a中初始化类b的对象
	
	这样通过类a直接去添加类b的对象引用，会导致类a与类b强耦合
	显然不满足程序的高内聚、低耦合的要求
	这时,我们再站在抽象的方法上看，抽取类a所需要类b的方法，通过接口/抽象类来指向类b的引用
	通过抽象，开放扩展，关闭修改 --> 方便维护

	通过抽象，本来由类a->类b 转换为了类a->接口/抽象->任意子类,虽然这种方式可以大大降低耦合，但难免会需要手动添加类a->接口/抽象->类b的引用，终究是类a在控制着具体引用的对象

	接下来，我们的IOC就登场了
	simple-->通过工厂设计模式,我们将 接口/抽象->任意子类 交给工厂去实现，这时便成为了类a->工厂->接口/抽象->具体子类   这个时候创建具体子类的步骤便是由工厂实现即由工厂来控制具体的对象引用而不是类a,这就是一个简单IOC 
	
	简单概括IOC:存在类a需要类b的对象引用,本来是由类a来决定如何创建类b的引用，却通过工厂/其他方式来创建类b的引用再返还给类a,从而实现了类a与类b低耦合

	deep-->虽然通过工厂能够实现,但是在存在大量实现类和大量的接口时，工厂的代码量会大大的增加，很显然，一般我们都不会乐意这样去做的
	这时，我们再参考一下比较流行的ioc框架--spring,在spring中，我们将需要引用的对象，统一添加到spring容器中(通过接口/抽象进行标识),然后在需要使用某个接口的实现时，直接通过spring容器来获取引用，同时spring容器还会帮你管理容器中对象的生命周期和scope(单例/每获取一个就创建一个对象/同一上下文共享一个对象 [在添加到spring容器时进行配置])
	注:spring通过xml配置文件来往spring容器中添加对象

	spring deep-->当所需要添加的对象过多时，我们的xml难免会比较大、比较多且xml中的约束并不能与类关联起来，这时我们就可以使用spring另一方式:注解和自动扫描来往spring容器中添加对象和从spring容器中获取对象 , 即通过反射扫描包下所有类，通过注解标识来获取需要添加的类， 获取对象时 ，同样的通过注解获取需要引用的类(一般是通过接口-->spring容器中查找相符合的实现类-->返还给类) 具体实现请参考 AOP+REFLECT+IOC+DI[内容过多...,]

	summary: 
		normal:类a->抽象->具体的实现类
		IOC:类a->工厂/容器->抽象    抽象->工厂/容器->具体的实现类
		即：抽象->具体的实现类这一步骤不由类a决定而是由工厂/容器来实现

### DI 依赖注入 ###
	
	其实通过对IOC的说明，已经大概的说明了DI
	即 类a需要类b的引用，即类a存在对类b的依赖，然后再通过工厂/容器进行注入(AOP+REFLECT...),通过抽象进行标识/约定
	就是一个从容器中获取对象的过程，本来是由类a自己来做，现在是由框架通过DI来进行

### 扩展小知识 ###

	在.net core2.0+中，就mvc这一方面，便已改为IOC+DI的方式，（对于之前经常使用spring.net的我来说真的是一个好消息） 由于spring是一个重量级的框架，在第一访问时往往会耗费比较多的时间来初始化,但.net core中的则是一个轻量级的框架.,

	注入方式：
		services.AddTransient<>()//每次请求创建一个示例,通过泛型T约定
        services.AddSingleton<>()//单例,通过泛型T约定
        services.AddScoped<>()//同一上下文(Scope)共享一个示例,通过泛型T约定

		一种类型仅保留一个实现类（所有ioc都是这样）

		然后目前注入的方式为构造方法注入(不知道后续有没有扩展)
		方式：
			1.获取所有(符合的)构造方法,即容器中存在满足构造函数里所有的参数
			2.获取一个存在所有参数的构造函数
				例如 con(A) con(B) con(A,B) 这时便会走con(A,B) 

	-------over~

> 注解的深入

1. 在IOC/DI中，通过注解可以往容器中添加对象，也可以从容器中取出对象
2. 在web中常常会配合拦截器/身份认证进行使用
3. 在传参时也可以作为传参约束进行使用
4. 在入参时，也可以帮助解析参数，例如:[FromBody][FromForm]...
5. 过时/重写等等

summary:简化项目代码的一大利器[特性、枚举...]

> web生命周期

![https://www.cnblogs.com/zgynhqf/p/5679032.html](https://images2015.cnblogs.com/blog/352688/201606/352688-20160613222444448-376688938.png)

在园子中有许多关于这方面的讲解，好文也比较多，个人一般是需要时再去看，没有较深的理解...

> 中间件的开发与使用

	框架 vs 类库
	一般来说，类库只是相当于一个工具箱,简单易用，由程序方进行处理
	而框架，则是相当于一个项目架构，当使用时，只需要进行配置，由框架进行处理
	所以在框架中，一般都是开发扩展，关闭维护，这时，扩展便是通过中间件来实现(大部分方式)

	在.net 中还可以通过扩展方法进行扩展
	例如：
		public static RETURN_TYPE EXTENSION_METHOD(this NEED_EXTENSION_CLASS info,OTHER PARAMS)

> 项目结构

	在.net 中 存在 framework/standard/core  
	framework和core共同遵循standard标准

> nlog

1. 添加依赖:NLog.Extensions.Logging
2. 在startup>configure中

		 loggerFactory.AddNLog();//添加NLog
         NLog.LogManager.LoadConfiguration($@"{env.ContentRootPath}/config/nlog.config");//指定NLog的配置文件

![https://www.cnblogs.com/qinjin/p/5134982.html](https://i.imgur.com/dx5CjBW.png)

参考博客园大神博文~

> 异步、多线程、线程池

这一部分，应该是学习的一个必经之路了。

### 什么是异步 ###

	<百度百科>

	异步：一种通讯方式，对设备需求简单。我们的PC机提供的标准通信接口都是异步的。
	异步双方不需要共同的时钟，也就是接收方不知道发送方什么时候发送，所以在发送的信息中就要有提示接收方开始接收的信息，如开始位，同时在结束时有停止位。
	异步的另外一种含义是计算机多线程的异步处理。与同步处理相对，异步处理不用阻塞当前线程来等待处理完成，而是允许后续操作，直至其它线程将处理完成，并回调通知此线程。
	但此处需要明确的是:异步与多线程与并行不是同一个概念.

[https://www.cnblogs.com/wisdomqq/archive/2012/03/29/2417723.html](https://www.cnblogs.com/wisdomqq/archive/2012/03/29/2417723.html "博文推荐")

介绍的比较详情，说明了应用场景.以及实现方式

### 什么是多线程 ###

	进程与线程

	一个应用就相当于一个进程，一个进程有多个线程
	例如，一个屋子里有很多人在进行工作，房子相当于进程，不同的人相当于不同的线程

	《属性说明》
	{"CurrentCulture":"zh-CN",//线程的区域性
	"CurrentUICulture":"zh-CN",//资源管理器用于在运行时查找区域性特定资源的当前区域性。
	"ExecutionContext":{},//当前线程的各种上下文的信息。
	"IsAlive":true,//
	"IsBackground":false,//只要存在一个前台线程存在，程序就不会退出
	"IsThreadPoolThread":false,
	"ManagedThreadId":3,//当前托管线程的唯一标识符。
	"Name":null,
	"Priority":2,//线程的调度优先级 [不准确]
	"ThreadState":0,
		Aborted         
		AbortRequested  
		Background      
		Running         
		Stopped         
		StopRequested   
		Suspended       
		SuspendRequested
		Unstarted       
		WaitSleepJoin   

	"ApartmentState":1}//此线程的单元状态。 
		STA//将创建并输入一个单线程单元。
		MTA//将创建并进入一个多线程单元。
		Unknown


### 锁 ###

	在多线程中，经常会出现多个线程操作同一信息的情况(例如数据库操作)
	由于有多个线程操作同一信息，但是每个线程中的信息存在信息不一致的情况，就容易导致操作后信息异常，此时，我们便可以对于信息进行加锁，一次只允许一个线程操作，操作完之后其他线程才可以操作[加锁会导致其他线程阻塞]

	死锁情况:
		1.当出现线程a锁住信息b操作信息c 的同时 线程d锁住信息c操作信息b 则会导致线程死锁。

	线程锁:大家都不陌生，主要用来给方法、代码块加锁。当某个方法或者代码块使用锁时，那么在同一时刻至多仅有有一个线程在执行该段代码。当有多个线程访问同一对象的加锁方法/代码块时，同一时间只有一个线程在执行，其余线程必须要等待当前线程执行完之后才能执行该代码段。但是，其余线程是可以访问该对象中的非加锁代码块的。
	
	进程锁:也是为了控制同一操作系统中多个进程访问一个共享资源，只是因为程序的独立性，各个进程是无法控制其他进程对资源的访问的，但是可以使用本地系统的信号量控制（操作系统基本知识）。

	分布式锁:当多个进程不在同一个系统之中时，使用分布式锁控制多个进程对资源的访问。

	主要还是看应用场景吧,谨慎加锁。

### 线程池 ###

	1.线程池中的线程都是backgroundThread

[https://www.cnblogs.com/leslies2/archive/2012/02/07/2310495.html](https://www.cnblogs.com/leslies2/archive/2012/02/07/2310495.html "精选博文")

----------

其实，感觉学习起来都比较容易，直接查看官方api按照指导来就ok了，一般比较好的框架，官方文档都比较全面

如果看起来比较困难就去搜一下相关的资料就好，百度、谷歌很容易

深入的话就是往数据结构、设计模式、框架方面去靠，其实最主要的还是要应用到实处，实战往往都是体现个人能力的最好方式

初学时，兴趣是最好的老师

深入时，创意是最好的动力

----------
author:monster

since:11/10/2018 11:08:44 AM 

direction:summary myself